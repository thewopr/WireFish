/*
 * CSCI 363 Computer Networks
 * Lab 10: Working with Ethernet Packet Traces
 *
 * Skeleton file for lab exercise.
 *
 * This is a skeleton program for analyzing Ethernet packet traces
 * generated by 'wireshark'.
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/ether.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <time.h>
#include <pcap.h>
#include <arpa/inet.h>

#define MAX_ETH_FRAME_LEN xxx  // maximum Ethernet frame length
int count = 0;
void printARP(const u_char *p) {

	struct arphdr * hdr = (struct arphdr *) (p + 0);
	unsigned short int op = hdr->ar_op;
	
	if( op == ARPOP_REQUEST)
		printf("ARP request\n");
	else if(op == ARPOP_REPLY)
		printf("ARP reply\n");
	else {
		printf("ARP Unknown\n");
	}
}

void printEthernetHeader(struct ether_header * eptr) {
	printf("dst addr = %s\n", ether_ntoa((const struct ether_addr *) &eptr->ether_dhost));
	printf("src addr = %s\n", ether_ntoa((const struct ether_addr *) &eptr->ether_shost));
}

void printEthernetBody(struct ip * p) {
	printf("IP packet length %d\n", p->ip_len);
	printf("src IP addr = %s\n", inet_ntoa(p->ip_src));
	printf("dest IP addr = %s\n", inet_ntoa(p->ip_dst));
}

void printEthernet(const u_char * packet) {
	printEthernetHeader((struct ether_header *) (packet + 0));
	printEthernetBody((struct ip*) (packet + sizeof(struct ether_header)));
}

void processPacket(u_char *args, const struct pcap_pkthdr* pkthdr, const u_char* packet) {

	u_int16_t type = ntohs( ((struct ether_header *) packet)->ether_type);
	
	printf("==== packet count %d ====\n", count);
	time_t tv = (pkthdr->ts).tv_sec;
	printf("captured time %s", ctime(&tv));
	printf("bytes captured %d\n", pkthdr->len);
	printf("length of packet %d\n",pkthdr->len);
	printf("type = 0x%02X\n", type);

	if(type == ETHERTYPE_IP) {
		printEthernet(packet);
	}		
	 else if(type == ETHERTYPE_ARP) {
		printARP(packet);	  
	}else if(type == ETHERTYPE_REVARP) {
	  printf("REARP Packet\n");
	}else {
		printf("Ethernet type 0x%02X not IP, not processed.\n\n", type);
	}
	count++;
	printf("\n");
}

int main(int argc, char* argv[]){

	if(argc < 1) {
		printf("Improper usage: %s [ packet capture ]\n", argv[0]);
		exit(1);
	}

	pcap_t *p;
	char errbuf[PCAP_ERRBUF_SIZE];

	p = pcap_open_offline(argv[1], errbuf);

	printf("==== GLOBAL HEADER ====\n");
	printf("host order is %s \n", pcap_is_swapped(p) ? "in order" : "out of order" );
	printf("major version %d\n", pcap_major_version(p));
	printf("minor version %d\n", pcap_minor_version(p));
	printf("maximum captured packet length %d\n", pcap_snapshot(p));
	printf("link layer type %d\n\n", pcap_datalink(p));

	pcap_loop(p, 1000, processPacket, NULL);

	pcap_close(p);
	return 1;
}
